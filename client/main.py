from ursina import *
from ursina.prefabs.first_person_controller import FirstPersonController
import asyncio
import websockets
import json
import threading
from network import NetworkClient  # 自訂網路

app = Ursina()

class Player(FirstPersonController):
    def __init__(self):
        super().__init__()
        self.hp = 100
        self.id = None  # 伺服器分配
        self.active_weapon = None

        # 載入武器模型
        self.weapons = {}
        weapon_names = ['vandal', 'phantom', 'operator', 'sheriff', 'classic']
        for w_name in weapon_names:
            # Note: The .glb files are not actually present. They need to be generated by the user.
            # This code assumes they exist in the specified path.
            self.weapons[w_name] = Entity(
                model=f'assets/models/weapons/{w_name}.glb',
                parent=camera,  # Attach to camera for view model
                position=(0.5, -0.5, 0.9),
                rotation=(-5, 10, 0),
                scale=0.1,
                enabled=False
            )
        self.switch_weapon('vandal') # Start with the Vandal

    def switch_weapon(self, weapon_name):
        for w in self.weapons.values():
            w.enabled = False

        if weapon_name in self.weapons:
            self.weapons[weapon_name].enabled = True
            self.active_weapon = self.weapons[weapon_name]
            # In a real scenario, you'd play an idle or equip animation here.
            # self.active_weapon.animate('idle')

    def shoot(self):
        if self.active_weapon:
            # Play shooting animation if it exists in the model
            # self.active_weapon.animate('shoot')
            print("Player shoots")
            network.send_shoot()

# 全局
local_player = None
remote_players = {}  # {id: Entity}
network = None
server_ip = "localhost:8765" # Default, can be changed in UI later

def start_network():
    def net_thread():
        # This will block until the connection is closed.
        asyncio.run(network.connect(server_ip))
    threading.Thread(target=net_thread, daemon=True).start()

def update():
    # 同步本地位置到伺服器
    if local_player and network and network.ws:
        network.send_position(local_player.position, local_player.rotation_y)

# 輸入
def input(key):
    if not local_player:
        return

    if key == 'left mouse down':
        local_player.shoot()

    # Weapon switching
    if key == '1': local_player.switch_weapon('vandal')
    if key == '2': local_player.switch_weapon('phantom')
    if key == '3': local_player.switch_weapon('operator')
    if key == '4': local_player.switch_weapon('sheriff')
    if key == '5': local_player.switch_weapon('classic')

# 初始化
def game_start():
    global local_player
    # A simple UI to get the server IP might be better in the future.
    # server_ip_input = input("伺服器IP:端口 (預設 localhost:8765): ") or "localhost:8765"
    # global server_ip
    # server_ip = server_ip_input

    Text("連線中...", origin=(0,0), scale=2)

    global network
    network = NetworkClient(on_sync=sync_players)
    start_network()

    # The game should wait for a connection confirmation from the server
    # before creating the player, but for now, we create it immediately.
    local_player = Player()
    # local_player.position = (0, 5, 0) # Start a bit higher
    camera.parent = local_player
    camera.position = (0, 2, 0) # Adjust camera height relative to player
    destroy(find_entity("連線中..."))

    # Simple ground
    ground = Entity(model='plane', scale=100, color=color.dark_gray, texture='white_cube', collider='box')


# 同步遠端玩家
def sync_players(data):
    # This function is called from the network thread, so we need to be careful
    # when modifying Ursina entities. It's often better to queue changes.
    # For now, direct modification might work but can cause issues.

    server_players = data.get('players', [])
    current_remote_ids = set(remote_players.keys())
    server_player_ids = {p['id'] for p in server_players if p['id'] != network.client_id}

    # Add new players
    for p_data in server_players:
        pid = p_data['id']
        if pid == network.client_id: # This is us
            if local_player and not local_player.id:
                local_player.id = pid
            continue

        if pid not in remote_players:
            print(f"Spawning remote player {pid}")
            remote_players[pid] = Entity(model='cube', color=color.orange, scale=(1, 1.8, 1), position=p_data['pos'])

        # Update existing players
        remote_players[pid].position = p_data['pos']
        remote_players[pid].rotation_y = p_data['rot']

    # Remove disconnected players
    for pid in current_remote_ids - server_player_ids:
        print(f"Destroying remote player {pid}")
        destroy(remote_players[pid])
        del remote_players[pid]


if __name__ == '__main__':
    game_start()
    app.run()
